defmodule LazyDoc.TaskTest do
  use ExUnit.Case

  alias Mix.Tasks.LazyDoc, as: TaskLazyDoc

  test "extract the names of a module" do
    {:ok, content} = File.read("lib/lazy_doc.ex")

    {:ok, ast, comments} =
      Code.string_to_quoted_with_comments(content,
        literal_encoder: &{:ok, {:__block__, &2, [&1]}},
        token_metadata: true,
        unescape: false
      )

    expected_names = [
      module: [:LazyDoc],
      function: {:my_func, "def my_func(n) do\n  \"is \#{inspect(n)}\"\nend"},
      function: {:my_func, "def my_func(2) do\n  \"is two\"\nend"},
      function: {:my_func, "def my_func(1) do\n  \"is one\"\nend"},
      function: {:func_without_doc, "def func_without_doc(), do: IO.puts(\"Hello world\")"},
      function: {:hello, "def hello do\n  :world\nend"},
      function: {:my_func_2, "def my_func_2(n) do\n  \"is \#{inspect(n)}\"\nend"},
      function: {:my_func_2, "def my_func_2(2) do\n  \"is two\"\nend"},
      function: {:my_func_2, "def my_func_2(1) do\n  \"is one\"\nend"}
    ]

    name_extraction = TaskLazyDoc.extract_names(ast)

    assert name_extraction == expected_names

    commets_texts = comments |> Enum.map(fn c -> c.text end)

    expected_comments = [
      "## This comment is just to ilustrate that the algorithm will",
      "## take the comments"
    ]

    assert commets_texts == expected_comments

    names_with_clauses_joined = name_extraction |> TaskLazyDoc.join_code_from_clauses()

    expected_names =
      [
        function:
          {:my_func_2,
           "def my_func_2(1) do\n  \"is one\"\nend\ndef my_func_2(2) do\n  \"is two\"\nend\ndef my_func_2(n) do\n  \"is \#{inspect(n)}\"\nend"},
        function: {:hello, "def hello do\n  :world\nend"},
        function: {:func_without_doc, "def func_without_doc(), do: IO.puts(\"Hello world\")"},
        function:
          {:my_func,
           "def my_func(1) do\n  \"is one\"\nend\ndef my_func(2) do\n  \"is two\"\nend\ndef my_func(n) do\n  \"is \#{inspect(n)}\"\nend"},
        module: [:LazyDoc]
      ]

    assert names_with_clauses_joined == expected_names
  end

  test "docs per module" do
    docs_per_module = TaskLazyDoc.docs_per_module([{:module, LazyDoc}])

    # This module is full documented so it returns none functions, it just returns the @module_doc
    # maybe returning the module_doc is wrong when we implement the @module_doc

    expected_result = [
      {:docs_v1, 2, :elixir, "text/markdown",
       %{
         "en" =>
           "Documentation for `LazyDoc`.\n\nThis module is an example of autogenerated docs by\nthe task provided.\n"
       }, %{}, []}
    ]

    assert docs_per_module == expected_result

    docs_per_module = TaskLazyDoc.docs_per_module([{:module, LazyDoc.ExampleModule}])

    expected_result =
      [
        {:docs_v1, 1, :elixir, "text/markdown", :none, %{},
         [
           {{:function, :hello, 1}, 3, ["hello(param)"], :none, %{}},
           {{:function, :hihi, 0}, 8, ["hihi()"], :none, %{}}
         ]}
      ]

    assert docs_per_module == expected_result
  end

  test "filter undocumented docs" do
    {:ok, content} = File.read("test/support/example_module.ex")

    {:ok, ast, _comments} =
      Code.string_to_quoted_with_comments(content,
        literal_encoder: &{:ok, {:__block__, &2, [&1]}},
        token_metadata: true,
        unescape: false
      )

    names = TaskLazyDoc.extract_names(ast)

    docs_per_module = TaskLazyDoc.docs_per_module([{:module, LazyDoc.ExampleModule}])

    all_none_function_docs =
      Enum.reduce(docs_per_module, [], fn {:docs_v1, _annotation, _beam_language, _format,
                                           _module_doc, _metadata, function_docs},
                                          acc ->
        function_docs ++ acc
      end)

    functions_to_document =
      TaskLazyDoc.filter_undocumented_functions(names, all_none_function_docs)

    assert functions_to_document |> Enum.map(fn {:function, {name, _code}} -> name end) == [
             :hihi,
             :hello
           ]
  end

  test "test docs_are_ok?" do
    assert TaskLazyDoc.docs_are_ok?(~s(@doc """\n pepe frog""")) == true
    assert TaskLazyDoc.docs_are_ok?("@doc \" queso curado \"") == true
    assert TaskLazyDoc.docs_are_ok?("pepe meme") == false
  end

  test "test docs_to_node" do
    {:ok, content} = File.read("test/support/example_module.ex")

    {:ok, ast, _comments} =
      Code.string_to_quoted_with_comments(content,
        literal_encoder: &{:ok, {:__block__, &2, [&1]}},
        token_metadata: true,
        unescape: false
      )

    docs = "@doc \"\"\"\npepe frog\n\"\"\""

    function_name = :hihi

    new_ast = TaskLazyDoc.docs_to_node(true, docs, ast, function_name)

    ## Check if the AST has @doc node before the :hihi node

    {:defmodule, _meta_mod, children} = new_ast

    [
      _aliases_node,
      [
        {{:__block__, _meta_block, [:do]}, {:__block__, _meta_inner_block, block_children}}
      ]
    ] = children

    index =
      Enum.find_index(block_children, fn elem ->
        match?({:def, _meta, [{:hihi, _meta_func, _params}, _func_block]}, elem)
      end)

    {:@, _meta_at,
     [
       {:doc, _meta_doc,
        [
          {:__block__, _meta_block, [message]}
        ]}
     ]} = Enum.at(block_children, index - 1)

    assert message == "pepe frog\n"
  end
end
